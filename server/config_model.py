# generated by datamodel-codegen:
#   filename:  config.yml
#   timestamp: 2022-11-04T16:37:55+00:00

from __future__ import annotations

from typing import List, Optional, Union, Dict

from pydantic import BaseModel, Field, BaseSettings, validator, root_validator

from server.common.errors import ConfigurationError
from server.common.utils.utils import is_port_available


class CspDirectives(BaseModel):
    img_src: List[str] = Field(..., alias='img-src')
    script_src: List[str] = Field(..., alias='script-src')
    connect_src: List[str] = Field(..., alias='connect-src')


class ServerApp(BaseSettings):
    verbose: bool
    debug: bool
    host: str
    port: Optional[int]
    open_browser: bool
    force_https: bool
    flask_secret_key: Optional[str]
    generate_cache_control_headers: bool
    server_timing_headers: bool
    csp_directives: Optional[List[CspDirectives]]
    api_base_url: Optional[str]
    web_base_url: Optional[str]

    @root_validator()
    def check_port(cls, values):
        if not is_port_available(values.host, values.port):
            raise ConfigurationError(
                f"The port selected {values.port} is in use, please configure an open port."
            )


class DatarootValue(BaseModel):
    base_url: str
    dataroot: str


class MultiDataset(BaseModel):
    dataroot: Optional[Union[str, Dict[str, DatarootValue]]]
    index: Union[bool, str] = Field(default=False)
    allowed_matrix_types: List[str]


class S3(BaseModel):
    region_name: Union[bool, str] = Field(default=True)


class DataLocator(BaseModel):
    api_base: Optional[str]
    s3: S3


class GeneInfo(BaseModel):
    api_base: Optional[str]


class TiledbCtx(BaseModel):
    sm_tile_cache_size: int = Field(..., alias='sm.tile_cache_size')
    py_init_buffer_bytes: int = Field(..., alias='py.init_buffer_bytes')


class CxgAdaptor(BaseModel):
    tiledb_ctx: TiledbCtx


class Adaptor(BaseModel):
    cxg_adaptor: CxgAdaptor


class Limits(BaseModel):
    column_request_max: int
    diffexp_cellcount_max: Optional[int]


class Server(BaseModel):
    app: ServerApp
    multi_dataset: MultiDataset
    data_locator: DataLocator
    gene_info: GeneInfo
    adaptor: Adaptor
    limits: Limits


class ScriptsItem(BaseModel):
    src: str
    integrity: str
    crossorigin: str


class DatasetApp(BaseModel):
    scripts: List[Union[str, ScriptsItem]]
    inline_scripts: List[str]
    about_legal_tos: Optional[str]
    about_legal_privacy: Optional[str]


class Presentation(BaseModel):
    max_categories: int
    custom_colors: bool


class Embeddings(BaseModel):
    names: List[str]


class Diffexp(BaseModel):
    enable: bool
    enable: bool
    lfc_cutoff: float
    top_n: int


class Dataset(BaseModel):
    app: DatasetApp
    presentation: Presentation
    embeddings: Embeddings
    diffexp: Diffexp
    X_approximate_distribution: str


class EnvironmentItem(BaseModel):
    name: str
    path: List[str]
    required: bool = Field(default=False)


class SecretItemValues(BaseModel):
    key: str
    path: List[str]
    required: Optional[bool] = Field(default=False)


class SecretsItem(BaseModel):
    name: str
    values: List[SecretItemValues]


class AwsSecretsManager(BaseModel):
    region: Optional[str]
    secrets: List[SecretsItem]


class External(BaseModel):
    environment: List[EnvironmentItem]
    aws_secrets_manager: AwsSecretsManager


class Config(BaseSettings):
    server: Optional[Server]
    dataset: Optional[Dataset]
    external: Optional[External]
